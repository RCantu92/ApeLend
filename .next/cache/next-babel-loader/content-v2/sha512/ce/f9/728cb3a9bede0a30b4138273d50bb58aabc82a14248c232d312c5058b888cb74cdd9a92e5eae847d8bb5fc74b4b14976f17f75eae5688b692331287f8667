{"ast":null,"code":"// May need to use this syntax for frontend:\nimport { ethers } from 'ethers';\nlet provider; // Conditional that uses the inject web3 from metamask\n// under certain conditions. Otherwise, it connects using\n// Alchemy.\n\nif (false && typeof window.web3 !== 'undefined') {\n  // A Web3Provider wraps a standard Web3 provider, which is\n  // what Metamask injects as window.ethereum into each page\n  // await window.ethereum.enable();\n  provider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = provider.getSigner();\n} else {\n  // We are on the server *OR* the user is not running metamask\n  const network = \"ropsten\";\n  provider = ethers.getDefaultProvider(network, {\n    alchemy: process.env.ALCHEMY_ROPSTEN\n  });\n  const signer = provider.getSigner;\n} // For Infura API (Use conditional in future, in case user does not have MetaMask)\n// (THIS IS FROM EATTHEBLOCKS)\n// const provider = new ethers.providers.AlchemyProvider('testnet name', INFURA_TESTNET_API_KEY);\n// Export instance of Ethers' provider\n\n\nexport default provider;","map":{"version":3,"sources":["/Users/robertocantu/blockchain_programming/ApeLend/ethers/ethers.js"],"names":["ethers","provider","window","web3","providers","Web3Provider","ethereum","signer","getSigner","network","getDefaultProvider","alchemy","process","env","ALCHEMY_ROPSTEN"],"mappings":"AAAA;AACA,SAASA,MAAT,QAAuB,QAAvB;AAEA,IAAIC,QAAJ,C,CAEA;AACA;AACA;;AACA,IAAI,SAAiC,OAAOC,MAAM,CAACC,IAAd,KAAuB,WAA5D,EAAyE;AACrE;AACA;AACA;AACAF,EAAAA,QAAQ,GAAG,IAAID,MAAM,CAACI,SAAP,CAAiBC,YAArB,CAAkCH,MAAM,CAACI,QAAzC,CAAX;AACA,QAAMC,MAAM,GAAGN,QAAQ,CAACO,SAAT,EAAf;AACH,CAND,MAMO;AACH;AACA,QAAMC,OAAO,GAAG,SAAhB;AACAR,EAAAA,QAAQ,GAAGD,MAAM,CAACU,kBAAP,CAA0BD,OAA1B,EAAmC;AAAEE,IAAAA,OAAO,EAAEC,OAAO,CAACC,GAAR,CAAYC;AAAvB,GAAnC,CAAX;AACA,QAAMP,MAAM,GAAGN,QAAQ,CAACO,SAAxB;AACH,C,CAEG;AACA;AACA;AAEJ;;;AACA,eAAeP,QAAf","sourcesContent":["// May need to use this syntax for frontend:\nimport { ethers } from 'ethers';\n\nlet provider;\n\n// Conditional that uses the inject web3 from metamask\n// under certain conditions. Otherwise, it connects using\n// Alchemy.\nif (typeof window !== 'undefined' && typeof window.web3 !== 'undefined') {\n    // A Web3Provider wraps a standard Web3 provider, which is\n    // what Metamask injects as window.ethereum into each page\n    // await window.ethereum.enable();\n    provider = new ethers.providers.Web3Provider(window.ethereum);\n    const signer = provider.getSigner();\n} else {\n    // We are on the server *OR* the user is not running metamask\n    const network = \"ropsten\";\n    provider = ethers.getDefaultProvider(network, { alchemy: process.env.ALCHEMY_ROPSTEN });\n    const signer = provider.getSigner;\n}\n\n    // For Infura API (Use conditional in future, in case user does not have MetaMask)\n    // (THIS IS FROM EATTHEBLOCKS)\n    // const provider = new ethers.providers.AlchemyProvider('testnet name', INFURA_TESTNET_API_KEY);\n\n// Export instance of Ethers' provider\nexport default provider;"]},"metadata":{},"sourceType":"module"}