{"ast":null,"code":"import _regeneratorRuntime from \"/Users/robertocantu/blockchain_programming/ApeLend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/robertocantu/blockchain_programming/ApeLend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nrequire(\"dotenv\").config({\n  path: \"./.env\"\n}); // Import Alchemy API key from nmeumonic\n\n\nvar alchemyRopsten = process.env.ALCHEMY_ROPSTEN; // const { ethers } = require(\"hardhat\");\n// May need to use this syntax for frontend:\n\nimport { ethers } from 'ethers'; // Conditional that uses the inject web3 from metamask\n// under certain conditions. Otherwise, it connects using\n// Alchemy.\n\nif (true && typeof window.web3 !== 'undefined') {\n  // A Web3Provider wraps a standard Web3 provider, which is\n  // what Metamask injects as window.ethereum into each page\n  await window.ethereum.enable();\n  var provider = new ethers.providers.Web3Provider(window.ethereum);\n  var signer = provider.getSigner();\n} else {\n  // We are on the server *OR* the user is not running metamask\n  var network = \"ropsten\";\n\n  var _provider = ethers.getDefaultProvider(network, {\n    alchemy: alchemyRopsten\n  });\n\n  var _signer = _provider.getSigner;\n}\n\nfunction main() {\n  return _main.apply(this, arguments);\n} // Export instance of Ethers' provider\n\n\nfunction _main() {\n  _main = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var provider, signer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return window.ethereum.enable();\n\n          case 2:\n            provider = new ethers.providers.Web3Provider(window.ethereum);\n            signer = provider.getSigner(); // For Infura API (Use conditional in future, in case user does not have MetaMask)\n            // (THIS IS FROM EATTHEBLOCKS)\n            // const provider = new ethers.providers.AlchemyProvider('testnet name', INFURA_TESTNET_API_KEY);\n            // For Infura API\n            // (FROM ETHERS DOCUMENTATION)\n            // const provider = ethers.getDefaultProvider(/*TESTNET NAME*/, { infura: YOUR_INFURA_PROJECT_ID });\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _main.apply(this, arguments);\n}\n\nexport default main;","map":{"version":3,"sources":["/Users/robertocantu/blockchain_programming/ApeLend/ethers/ethers.js"],"names":["require","config","path","alchemyRopsten","process","env","ALCHEMY_ROPSTEN","ethers","window","web3","ethereum","enable","provider","providers","Web3Provider","signer","getSigner","network","getDefaultProvider","alchemy","main"],"mappings":";;;AAAAA,OAAO,CAAC,QAAD,CAAP,CAAkBC,MAAlB,CAAyB;AAACC,EAAAA,IAAI,EAAE;AAAP,CAAzB,E,CACA;;;AACA,IAAMC,cAAc,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAAnC,C,CACA;AACA;;AACA,SAASC,MAAT,QAAuB,QAAvB,C,CAGA;AACA;AACA;;AACA,IAAI,QAAiC,OAAOC,MAAM,CAACC,IAAd,KAAuB,WAA5D,EAAyE;AACrE;AACA;AACA,QAAMD,MAAM,CAACE,QAAP,CAAgBC,MAAhB,EAAN;AACA,MAAMC,QAAQ,GAAG,IAAIL,MAAM,CAACM,SAAP,CAAiBC,YAArB,CAAkCN,MAAM,CAACE,QAAzC,CAAjB;AACA,MAAMK,MAAM,GAAGH,QAAQ,CAACI,SAAT,EAAf;AACH,CAND,MAMO;AACH;AACA,MAAMC,OAAO,GAAG,SAAhB;;AACA,MAAML,SAAQ,GAAGL,MAAM,CAACW,kBAAP,CAA0BD,OAA1B,EAAmC;AAAEE,IAAAA,OAAO,EAAEhB;AAAX,GAAnC,CAAjB;;AACA,MAAMY,OAAM,GAAGH,SAAQ,CAACI,SAAxB;AACH;;SAEcI,I;;EAgBf;;;;mEAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAGUZ,MAAM,CAACE,QAAP,CAAgBC,MAAhB,EAHV;;AAAA;AAIUC,YAAAA,QAJV,GAIqB,IAAIL,MAAM,CAACM,SAAP,CAAiBC,YAArB,CAAkCN,MAAM,CAACE,QAAzC,CAJrB;AAKUK,YAAAA,MALV,GAKmBH,QAAQ,CAACI,SAAT,EALnB,EAOI;AACA;AACA;AAEA;AACA;AACA;;AAbJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAiBA,eAAeI,IAAf","sourcesContent":["require(\"dotenv\").config({path: \"./.env\"});\n// Import Alchemy API key from nmeumonic\nconst alchemyRopsten = process.env.ALCHEMY_ROPSTEN;\n// const { ethers } = require(\"hardhat\");\n// May need to use this syntax for frontend:\nimport { ethers } from 'ethers';\n\n\n// Conditional that uses the inject web3 from metamask\n// under certain conditions. Otherwise, it connects using\n// Alchemy.\nif (typeof window !== 'undefined' && typeof window.web3 !== 'undefined') {\n    // A Web3Provider wraps a standard Web3 provider, which is\n    // what Metamask injects as window.ethereum into each page\n    await window.ethereum.enable()\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    const signer = provider.getSigner();\n} else {\n    // We are on the server *OR* the user is not running metamask\n    const network = \"ropsten\";\n    const provider = ethers.getDefaultProvider(network, { alchemy: alchemyRopsten });\n    const signer = provider.getSigner;\n}\n\nasync function main() {\n    // A Web3Provider wraps a standard Web3 provider, which is\n    // what Metamask injects as window.ethereum into each page\n    await window.ethereum.enable()\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    const signer = provider.getSigner();\n\n    // For Infura API (Use conditional in future, in case user does not have MetaMask)\n    // (THIS IS FROM EATTHEBLOCKS)\n    // const provider = new ethers.providers.AlchemyProvider('testnet name', INFURA_TESTNET_API_KEY);\n\n    // For Infura API\n    // (FROM ETHERS DOCUMENTATION)\n    // const provider = ethers.getDefaultProvider(/*TESTNET NAME*/, { infura: YOUR_INFURA_PROJECT_ID });\n}\n\n// Export instance of Ethers' provider\nexport default main;"]},"metadata":{},"sourceType":"module"}