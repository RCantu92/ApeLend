{"ast":null,"code":"// May need to use this syntax for frontend:\nimport { ethers } from 'ethers';\nvar signer;\nwindow.ethereum.enable(); // A Web3Provider wraps a standard Web3 provider, which is\n// what Metamask injects as window.ethereum into each page\n\nvar provider = new ethers.providers.Web3Provider(window.ethereum);\nsigner = provider.getSigner();\n/*\n// Creating variable instance of\n// provider to give value based\n// if using MetaMask or not.\nlet signer;\n\n// Conditional that uses the inject web3 from metamask\n// under certain conditions. Otherwise, it connects using\n// Alchemy.\nif (typeof window !== 'undefined' && typeof window.web3 !== 'undefined') {\n    window.ethereum.enable();\n    // A Web3Provider wraps a standard Web3 provider, which is\n    // what Metamask injects as window.ethereum into each page\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    signer = provider.getSigner();\n} else {\n    // FIX, RIGHT NOW WE *HAVE* TO USE METAMASK, OTHERWISE ERRORS OUT\n    // We are on the server *OR* the user is not running metamask\n    // const network = \"ropsten\";\n    //const provider = ethers.getDefaultProvider(network, { alchemy: process.env.ALCHEMY_ROPSTEN });\n    const provider = new ethers.providers.JsonRpcProvider(`https://eth-ropsten.alchemyapi.io/v2/${process.env.ALCHEMY_ROPSTEN}`);\n    signer = provider.getSigner();\n}\n\n    // For Infura API (Use conditional in future, in case user does not have MetaMask)\n    // (THIS IS FROM EATTHEBLOCKS)\n    // const provider = new ethers.providers.AlchemyProvider('testnet name', INFURA_TESTNET_API_KEY);\n*/\n// Export instance of Ethers' provider\n\nexport default signer;","map":{"version":3,"sources":["/Users/robertocantu/blockchain_programming/ApeLend/ethers/ethers.js"],"names":["ethers","signer","window","ethereum","enable","provider","providers","Web3Provider","getSigner"],"mappings":"AAAA;AACA,SAASA,MAAT,QAAuB,QAAvB;AAEA,IAAIC,MAAJ;AACAC,MAAM,CAACC,QAAP,CAAgBC,MAAhB,G,CACA;AACA;;AACA,IAAMC,QAAQ,GAAG,IAAIL,MAAM,CAACM,SAAP,CAAiBC,YAArB,CAAkCL,MAAM,CAACC,QAAzC,CAAjB;AACAF,MAAM,GAAGI,QAAQ,CAACG,SAAT,EAAT;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,eAAeP,MAAf","sourcesContent":["// May need to use this syntax for frontend:\nimport { ethers } from 'ethers';\n\nlet signer;\nwindow.ethereum.enable();\n// A Web3Provider wraps a standard Web3 provider, which is\n// what Metamask injects as window.ethereum into each page\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\nsigner = provider.getSigner();\n\n/*\n// Creating variable instance of\n// provider to give value based\n// if using MetaMask or not.\nlet signer;\n\n// Conditional that uses the inject web3 from metamask\n// under certain conditions. Otherwise, it connects using\n// Alchemy.\nif (typeof window !== 'undefined' && typeof window.web3 !== 'undefined') {\n    window.ethereum.enable();\n    // A Web3Provider wraps a standard Web3 provider, which is\n    // what Metamask injects as window.ethereum into each page\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    signer = provider.getSigner();\n} else {\n    // FIX, RIGHT NOW WE *HAVE* TO USE METAMASK, OTHERWISE ERRORS OUT\n    // We are on the server *OR* the user is not running metamask\n    // const network = \"ropsten\";\n    //const provider = ethers.getDefaultProvider(network, { alchemy: process.env.ALCHEMY_ROPSTEN });\n    const provider = new ethers.providers.JsonRpcProvider(`https://eth-ropsten.alchemyapi.io/v2/${process.env.ALCHEMY_ROPSTEN}`);\n    signer = provider.getSigner();\n}\n\n    // For Infura API (Use conditional in future, in case user does not have MetaMask)\n    // (THIS IS FROM EATTHEBLOCKS)\n    // const provider = new ethers.providers.AlchemyProvider('testnet name', INFURA_TESTNET_API_KEY);\n*/\n\n// Export instance of Ethers' provider\nexport default signer;"]},"metadata":{},"sourceType":"module"}